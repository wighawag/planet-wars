import { isPrivateWindow } from './utils/web';
import {Wallet} from "@ethersproject/wallet";
import {Web3Provider} from "@ethersproject/providers";
import {makeLog} from "./utils/log";
import {writable} from "./utils/store";
import {fetchEthereum, getVendor} from "./utils/builtin"
import {timeout} from "./utils"
let logger;

const $wallet = {
    builtin: {
      status: undefined, // Probing | Available | None | Error
      vendor: undefined
    },
    balance: {
      status: undefined, // Ready | Loading | Error
      amount: undefined,
      blockNumber: undefined
    },
    selected: {
      status: undefined, // Loading | Ready | Error
      type: undefined
    },
    lock: {
      status: undefined // Locked | Unlocking | Error
    },
    status: undefined, // Ready | Loading | Error
    address: undefined,
    selection: undefined,  // wallet Types available
    pendingUser: undefined, // 'Transaction' | 'Signature' | Unlock....
};
const $transactions = [];
const walletStore = writable($wallet);
const transactionsStore = writable($transactions);
const hidden = {
  provider: undefined,
  fallBackProvider: undefined
}

function set(obj) {
  for (let key of Object.keys(obj)) {
    if ($wallet[key] && typeof obj[key] === "object") {
      for (let subKey of Object.keys(obj[key])) { // TODO recursve
        $wallet[key][subKey] = obj[key][subKey];
      }
    } else {
      $wallet[key] = obj[key];
    }
  }
  logger.debug('WALLET', JSON.stringify($wallet, null, '  '));
  walletStore.set($wallet);
}
// //////////////////////////////////////////////////////////////////////////////

let ethersProvider;
let builtinWeb3Provider;

async function select(type) {
  if (!type) {
    if (!$wallet.selection || $wallet.selection.length === 0) {
      type = "builtin";
    } else if($wallet.selection.length === 1) {
      type = $wallet.selection[0];
    } else {
      const message = `No Wallet Type Specified, choose from ${$wallet.selection}`;
      set({selected: {status: "Error", message}});
      throw new Error(message);
    }
  }
  if (type == "builtin" && $wallet.builtin.status === "None") {
    const message = `No Builtin Wallet`;
    set({selected: {status: "Error", message}});
    throw new Error(message);
  } // TODO other type: check if module registered
  
  
  set({address: undefined, status: undefined, selected: {type, status: "Loading", previousType: $wallet.selected.type, message: undefined}, lock: {status: undefined}}); // RESET
  let web3Provider;
  if (type === 'builtin') {
    await probe();
    web3Provider = builtinWeb3Provider;
  } else {
    // TODO load module
  }

  if (!web3Provider) {
    const message = `no provider found for wallet type ${type}`
    set({selected: {status: "Error", message}});
    throw new Error(message);
  }

  set({selected: {type, status: "Ready"}});
  ethersProvider = new Web3Provider(web3Provider); 

  let accounts;
  try {
    if ($wallet.builtin.vendor === "Metamask") {
      accounts = await timeout(1000, ethersProvider.listAccounts(), {error: `Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)`}); // TODO timeout checks (metamask, portis)
    } else {
      // TODO timeout warning
      accounts = await timeout(20000, ethersProvider.listAccounts());
    }
  } catch (e) {
    set({status: "Error", message: e.message || e});
    throw e;
  }
  set({
    address: accounts ? accounts[0] : undefined,
    status: 'Ready',
    lock: {status: accounts && accounts.length > 0 ? "Unlocked" : "Locked"}
  });
}

let probing;
function probe() {
  if (probing) {
    return probing;
  }
  probing = new Promise(async (resolve, reject) => {
    if ($wallet.builtin.status) {
      return resolve();
    }
    set({builtin: {status: "Probing"}});
    try {
      builtinWeb3Provider = await fetchEthereum();
      if (builtinWeb3Provider) {
        set({builtin: {status: "Available", vendor: getVendor(builtinWeb3Provider)}}); 
      } else {
        set({builtin: {status: "None", vendor: undefined}});
      }
    } catch (e) {
      set({builtin: {status: "Error", message: e.message || e, vendor: undefined}});
      return reject(e);
    }
    resolve();
  });
  return probing;
}

// function autoSelect() {
//   if (!$wallet.selection || $wallet.selection.length === 0 || ($wallet.selection.length === 1 && $wallet.selection[0] === "builtin")) {
//    // try to get account directly if possible (TODO: need to handle Opera quircks, also Brave)
//     return select({
//       provider: builtinProvider,
//       type: "builtin"
//     });
//   }
// }

async function connect(type) {
  await select(type);
  if ($wallet.lock.status === "Locked") {
    return unlock();
  }
  return true;
}

function aknowledgeError(field) {
  if (field === "builtin") {

  }
}

let unlocking;
function unlock() {
  if (unlocking) {
    return unlocking;
  }
  let resolved = false;
  const p = new Promise(async (resolve, reject) => {
    // TODO Unlocking to retry // TODO add timeout
    if ($wallet.lock.status === "Locked") {
      set({lock: {status: 'Unlocking'}, pendingUser: "Unlock"});
      let accounts;
      try {
        accounts = await ethersProvider.send("eth_requestAccounts", []);
      } catch (e) {
        accounts = [];
      }
      if (accounts.length > 0) {
        set({address: accounts[0], lock:{status: 'Unlocked'}, pendingUser: undefined});
      } else {
        set({lock:{status: 'Locked'}, pendingUser: undefined});
        unlocking = null;
        resolved = true;
        return resolve(false);
      }
      unlocking = null;
      resolved = true;
      return resolve(true);
    } else {
      resolved = true;
      return reject(new Error(`Not Locked`));
    }
  });
  if (!resolved) {
    unlocking = p;
  }
  return p;
}

// /////////////////////////////////////////////////////////////////////////////////
export default ({log, debug}) => {
  logger = makeLog(log);
  if (debug && typeof window !== 'undefined') {
    window.$wallet = $wallet;
    window.$transactions = $transactions;
  }

  return {
    transactions: {
      subscribe: transactionsStore.subscribe
    },
    wallet: {
      subscribe: walletStore.subscribe,
      probe,
      connect,
      unlock,
      get contracts() {
        return contracts();
      },
      // logout,
      get addess() {
        return $wallet.addess;
      },
      get provider() {
        return hidden.provider;
      },
      get fallBackProvider() {
        return hidden.fallBackProvider;
      }
    }
  };
};
