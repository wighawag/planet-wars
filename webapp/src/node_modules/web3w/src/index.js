import { isPrivateWindow } from './utils/web';
import {Wallet} from "@ethersproject/wallet";
import {Web3Provider} from "@ethersproject/providers";
import {Contract} from "@ethersproject/contracts";
import {makeLog} from "./utils/log";
import {writable} from "./utils/store";
import {fetchEthereum, getVendor} from "./utils/builtin"
import {timeout} from "./utils"
let logger;

const $wallet = {
    builtin: {
      status: undefined, // Probing | Available | None | Error
      error: undefined,
      vendor: undefined
    },
    balance: {
      status: undefined, // Loading | Ready
      amount: undefined,
      error: undefined,
      blockNumber: undefined
    },
    contracts: {
      status: undefined, // Loading | Ready
      error: undefined
    },
    status: undefined, // Loading | Locked | Ready
    address: undefined,
    
    selection: undefined,  // wallet Types available
    selected: undefined,
    
    error: undefined,
  
    pendingUser: undefined, // 'Transaction' | 'Signature' | Unlock....
};
const $transactions = [];
const walletStore = writable($wallet);
const transactionsStore = writable($transactions);
const hidden = {
  provider: undefined,
  fallBackProvider: undefined
}

function set(obj) {
  for (let key of Object.keys(obj)) {
    if ($wallet[key] && typeof obj[key] === "object") {
      for (let subKey of Object.keys(obj[key])) { // TODO recursve
        $wallet[key][subKey] = obj[key][subKey];
      }
    } else {
      $wallet[key] = obj[key];
    }
  }
  logger.debug('WALLET', JSON.stringify($wallet, null, '  '));
  walletStore.set($wallet);
}

function reset(fields) {
  if (typeof fields === "string") {
    fields = [fields];
  }
  for(const field of fields) {
    const current = $wallet[field];
    if (typeof current === "object") {
      $wallet[field] = {status:undefined};
    } else {
      $wallet[field] = undefined;
    }
  }
}
// //////////////////////////////////////////////////////////////////////////////

let _ethersProvider;
let _builtinWeb3Provider;
let _contracts = {};
let _contractsInfos;

async function setup(address, extra) {
  set({contracts: {status: 'Loading'}});
  // TODO check chainId // TODO support both .chainId and chainId config ?
  if (_contractsInfos) {
    if (typeof _contractsInfos === "function") {
      _contractsInfos = await _contractsInfos();
    }

    for (const contractInfo of Object.keys(_contractsInfos)) {
      _contracts[contractInfo.name] = new Contract(contractInfo.address, contractInfo.abi, _ethersProvider.getSigner(address));
    }
  }
  
  set({contracts: {status: 'Ready'}}); // TODO None ?
}

async function select(type) {
  if (!type) {
    if (!$wallet.selection || $wallet.selection.length === 0) {
      type = "builtin";
    } else if($wallet.selection.length === 1) {
      type = $wallet.selection[0];
    } else {
      const message = `No Wallet Type Specified, choose from ${$wallet.selection}`;
      // set({error: {message, code: 1}}); // TODO code
      throw new Error(message);
    }
  }
  if (type == "builtin" && $wallet.builtin.status === "None") {
    const message = `No Builtin Wallet`;
    // set({error: {message, code: 1}}); // TODO code
    throw new Error(message);
  } // TODO other type: check if module registered
  
  reset(["address", "status", "message", "selected", "lock"]);
  set({selected: type, previousType: $wallet.selected, status: "Loading"});
  let web3Provider;
  if (type === 'builtin') {
    await probe();
    web3Provider = _builtinWeb3Provider;
  } else {
    // TODO load module
  }

  if (!web3Provider) {
    const message = `no provider found for wallet type ${type}`
    set({error: {message, code: 1}}); // TODO code
    throw new Error(message);
  }

  _ethersProvider = new Web3Provider(web3Provider); 

  let accounts;
  try {
    if ($wallet.builtin.vendor === "Metamask") {
      accounts = await timeout(1000, _ethersProvider.listAccounts(), {error: `Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)`}); // TODO timeout checks (metamask, portis)
    } else {
      // TODO timeout warning
      accounts = await timeout(20000, _ethersProvider.listAccounts());
    }
  } catch (e) {
    set({error: e});
    throw e;
  }
  const address = accounts && accounts[0];
  if (address) {
    set({
      address,
      status: 'Ready'
    });
    await setup(address);
  } else {
    set({
      address: undefined,
      status: 'Locked',
    });
  }
  
}

let probing;
function probe() {
  if (probing) {
    return probing;
  }
  probing = new Promise(async (resolve, reject) => {
    if ($wallet.builtin.status) {
      return resolve();
    }
    set({builtin: {status: "Probing"}});
    try {
      _builtinWeb3Provider = await fetchEthereum();
      if (_builtinWeb3Provider) {
        set({builtin: {status: "Available", vendor: getVendor(_builtinWeb3Provider)}}); 
      } else {
        set({builtin: {status: "None", vendor: undefined}});
      }
    } catch (e) {
      set({builtin: {status: "Error", message: e.message || e, vendor: undefined}});
      return reject(e);
    }
    resolve();
  });
  return probing;
}

// function autoSelect() {
//   if (!$wallet.selection || $wallet.selection.length === 0 || ($wallet.selection.length === 1 && $wallet.selection[0] === "builtin")) {
//    // try to get account directly if possible (TODO: need to handle Opera quircks, also Brave)
//     return select({
//       provider: builtinProvider,
//       type: "builtin"
//     });
//   }
// }

async function connect(type) {
  await select(type);
  if ($wallet.status === "Locked") {
    return unlock();
  }
  return true;
}

function aknowledgeError(field) {
  if (field === "builtin") {

  }
}

let unlocking;
function unlock() {
  if (unlocking) {
    return unlocking;
  }
  let resolved = false;
  const p = new Promise(async (resolve, reject) => {
    // TODO Unlocking to retry // TODO add timeout
    if ($wallet.status === "Locked") {
      set({pendingUser: "Unlock"});
      let accounts;
      try {
        accounts = await _ethersProvider.send("eth_requestAccounts", []);
      } catch (e) {
        accounts = [];
      }
      if (accounts.length > 0) {
        const address = accounts[0];
        set({
          address,
          status: 'Ready',
          pendingUser: undefined
        });
        await setup(address);
      } else {
        set({pendingUser: undefined});
        unlocking = null;
        resolved = true;
        return resolve(false);
      }
      unlocking = null;
      resolved = true;
      return resolve(true);
    } else {
      resolved = true;
      return reject(new Error(`Not Locked`));
    }
  });
  if (!resolved) {
    unlocking = p;
  }
  return p;
}

// /////////////////////////////////////////////////////////////////////////////////
export default (config) => {
  config = config || {};
  const {log, debug, contracts} = config;

  _contractsInfos = contracts;
  logger = makeLog(log);
  if (debug && typeof window !== 'undefined') {
    window.$wallet = $wallet;
    window.$transactions = $transactions;
  }

  return {
    transactions: {
      subscribe: transactionsStore.subscribe
    },
    wallet: {
      subscribe: walletStore.subscribe,
      probe,
      connect,
      unlock,
      get contracts() {
        return contracts();
      },
      // logout,
      get addess() {
        return $wallet.addess;
      },
      get provider() {
        return hidden.provider;
      },
      get fallBackProvider() {
        return hidden.fallBackProvider;
      }
    }
  };
};
