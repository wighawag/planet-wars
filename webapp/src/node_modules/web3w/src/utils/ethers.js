export class ContractWrap extends Proxy {
  constructor(contract, name) {

    this.name = name;
    this.contract = contract;
    this.proxies = {};
    
    this.functionsProxy = new Proxy(this.contract.functions, {
      get: (functions, methodName) => {
        return this.proxyCall(functions, methodName);
      }
    });

    super(contract, {
      get: (obj, prop) => {
        if (prop === "functions") {
          return this.functionsProxy;
        } else if (this.contract.functions[prop]) {
          return this.proxyCall(this.contract.functions, prop);
        } else {
          return obj[prop];
        }
      }
    });
  }

  proxyCall(functions, methodName) {
    let callProxy = this.proxies[methodName];
    if (!callProxy) {
      const methodInterface = this.contract.interface.functions[methodName];

      callProxy = new Proxy(functions[methodName], {
        apply: async (method, thisArg, argumentsList) => {
          const numArguments = argumentsList.length;
          let overrides;
          if (numArguments === methodInterface.inputs.length + 1 && typeof(argumentsList[numArguments - 1]) === "object") {
            overrides = argumentsList[numArguments];
          }
          console.log(`Calling  ${this.name}.${methodName} with ${overrides}`);
          const tx = await method(...argumentsList); // TODO bind ?
          console.log(`with hash : ${tx.hash}`);
          return tx;
        }
      })
      this.proxies[methodName] = callProxy;
    }
    return callProxy;
  }
}

const noop = (() => {});
class SignerProxy extends Proxy {
  constructor(signer, applyMap, {onTxRequest, onTxSent, onSignatureRequest, onSignatureReceived}) {
    applyMap = Object.assign({
      sendTransaction: async (method, thisArg, argumentsList) => {
        onTxRequest(argumentsList[0]);
        const tx = await method.bind(thisArg)(...argumentsList);
        onTxSent(tx);
        return tx;
      },
      signMessage: (method, thisArg, argumentsList) => {
        onSignatureRequest(argumentsList[0]);
        const signature = await method.bind(thisArg)(...argumentsList);
        onSignatureReceived(signature);
        return signature;
      }
    }, applyMap);
    this.signer = signer;
    this.proxies = {};
    super(signer, {
      get: (obj, prop) => {
        const applyFunc = applyMap[prop];
        if (applyFunc) {
          return  this.getProxy(prop, {
            apply: applyFunc
          });
        } else {
          return obj[prop];
        }
      }
    });
  }
  getProxy(methodName, handler) {
    let proxy = this.proxies[methodName]
    if (!proxy) {
      proxy = new Proxy(this.signer[methodName], handler);
      this.proxies[methodName] = proxy;
    }
    return proxy;
  }
}

export class UncheckedJsonRpcSignerWrap extends SignerProxy {
  constructor(signer) {
    super(signer, {});
  }
}

export class JsonRpcSignerWrap extends SignerProxy {
  constructor(signer, observers) {
    observers = observers ? {...observers} : {};
    observers = {
      onTxRequest: observers.onTxRequest || noop,
      onTxSent: observers.onTxSent || noop,
      onSignatureRequest: observers.onSignatureRequest || noop,
      onSignatureReceived: observers.onSignatureReceived || noop
    }
    super(signer, {
      connectUnchecked: (method, thisArg, argumentsList) => {
        const signer = method.bind(thisArg)(...argumentsList);
        return UncheckedJsonRpcSignerWrap(signer, observers);
      }
    }, observers);
  }
}

export class Web3ProviderWrap extends Proxy {
  constructor(provider) {
    this.provider = provider;
    this.proxies = {};
    
    this.getSignerProxy = new Proxy(this.provider.getSigner, {
      apply: (getSigner, thisArg, argumentsList) => {
        const signer = getSigner.bind(this.provider)(...argumentsList);
        return JsonRpcSignerWrap(signer);
      }
    })

    super(contract, {
      get: (obj, prop) => {
        if (prop === "getSigner") {
          return this.getSignerProxy;
        } else {
          return obj[prop];
        }
      }
    });
  }
}

// TODO Proxy
// export class JsonRpcSignerWrap extends JsonRpcSigner {
//   async sendTransaction(transaction) {
//     await super.sendTransaction(transaction);
//   }

//   async signTransaction(transaction) {
//     const result = await super.signTransaction(transaction);
//     return result;
//   }

//   async sendTransaction(transaction) {
//     const result = await super.sendTransaction(transaction);
//     return result;
//   }

//   async signMessage(message) {
//     const result = await super.signMessage(message);
//     return result;
//   }

//   connectUnchecked() {
//     return new UncheckedJsonRpcSignerWrap(_constructorGuard, this.provider, this._address || this._index);
//   }
// }

// export class UncheckedJsonRpcSignerWrap extends UncheckedJsonRpcSigner {
//   async sendTransaction(transaction) {
//     await super.sendTransaction(transaction);
//   }

//   async signTransaction(transaction) {
//     const result = await super.signTransaction(transaction);
//     return result;
//   }

//   async sendTransaction(transaction) {
//     const result = await super.sendTransaction(transaction);
//     return result;
//   }

//   async signMessage(message) {
//     const result = await super.signMessage(message);
//     return result;
//   }
// }

// export class Web3ProviderWrap extends Web3Provider {
//   getSigner(addressOrIndex) {
//     return new JsonRpcSignerWrap(_constructorGuard, this, addressOrIndex);
//   }
// }
